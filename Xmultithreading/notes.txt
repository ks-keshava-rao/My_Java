Mutliprogramming ----> Multi user 
       |-----> Multi Tasking ----> Mutltithreading
1. More than one program running simultaneously for one user is called multitasking . WINDOWS MACos
2. Mutltithreading different tasks in an single application , doesn't block the user because threads are independent .
3. threads are light weighted compared to task , they are sub process , smallest unit of processing. 
4. CPU runs , the threds alternatively but feels like they are runing together . 
5. mutliprocessing + multithreading = multitasking . 
6. Threads use shared memory they don't allocate separate memory and easy context switching . 
7. process based multitasking(mutliprocessing) :- dedicated addrress in memory , heavy weight process , expensive communication b/w .
8. Thread based multitasking(multithreading):- shared address space , lightweight , inexpensive communication , at a time one thread is executed . 
9. Two things available for achieveing multithreading 1. Thread class (provides mechanism) 2. Runnable Interface ()
10. Thread class :- multithreading for own class then extend thread into the class . 
11. Runnable interface :- if class is already extending from other class then implement runnable because java allows only one class to extend at a time . 
12. Lifecycle of a thread :- New , Active , Blocked/waiting , timed waiting , Terminated . 
13. STATES of a Thread 
https://share.anysnap.app/fpzxGUp4C1AQ
       New:- when a new thread is created and code hasn't run and executed yet . only start() method can be called in this state . 
       Active:- invoked when start() method is called , it has two states . 
              1. Runnable state :-
                     1. Ready to run , maybe running or ready to run at the given instant of time 
                     2. Duty of scheuler to allocate the time for thread to run . 
                     3. Each thread has a time slot assinged for execution and are served by CPU on first come first serve manner 
                        process of allocating time to threads is knows as time slicing , runnable state has a queue where all the threads lie waiting for their turn . 
                     4. A thread can come into runnable state from running , waiting or new states 
              2. Running state:- 
                     1. Processor has allocated time slot for the thread execution and it's run method. 
                     2. Thread can come into running state only from the runnable state . 
                     3. Running thread may giveup control when sleep() method is invoked goes out of queues , the enters runnable state when time period elaspses . 
                        when thread is suspended using suspend() for some time to satisfy conditions  . can be revived using resume() method .
                        when wait() is called on thread to wait for sometime , can be run again using notify() or notifyall() 
       Blocked or Waiting :- 
                     1. Whenever the thread is  inactive for a span of time temporarily . 
                     2. When main thread invokes join() it moves to waiting , then waits for child thread to complete tasks , once completed sends 
                        a notification to main thread to move to active thread . 
                     3. Duty of thread scheduler to prioritise which thread to run incase of more threads accumulation . 
       Timed Waiting :- 
                     1. longer waiting leads to starvation . 
                     2. if a thread is executing a critical part then another thread has to wait forever to avoid this 
                        the another thread is kept in timed waiting to avoid startvation .
                     3. using sleep() method this is achieved .
       Terminated state:- 
                     1. Terminated state is where the thread has finished it's job 
                     2. abnormal termination occurs when some unusual events like unhandled exception or segmentation fault occurs . 
                     3. when the run() method completes it's execution of statements . 
                     4. thread can also be dead by using stop() method . 
14. Thread priorities :- 
                     1. by default priority is 5 
                     2. min is 1 max is 10 . 
                     3. ex- keyboard input - T1 high priority , auto checker - low priority . 
                            , fetching data is priority , rendering is less priority . 
                     4. Java has own multithreading system , jvm has own scheduler.

 15. Thread class :- 1. Thread()
                     2. Thread(Runnable r)
                     3. Thread(Runnable r,String name)
                     4. Thread(ThreadGroup g, String name)  
                     5. Thread(String name)                 
16.getxxx()/setxxx():- 1. long getId() //JVM id for the thread 
   Enquiry methods     2. String getName()
                       3. int getPriority()
                       4. ThreadState getState()
                       5. ThreadGroup getThreadGroup()
                       6. void setName(String name)
                       7. void setPriority( int p)
                       8. void setDaemon(boolean d) // Daemon thread a thread which runs in background with least priority ex:- autosave , garbage collector .
                       9. boolean isAlive() 
                       10. boolean isDaemon()
                       11. boolean isInterrupted() // a method interrupt can interrupt a thread . 
17. Instance methods :- 1. void interrupt() // this will interrupt a thread . mostly done in case of waiting or sleeping 
                        2. void join() // when a thread is finished it's job instead of getting terminated it can wait for other threads to complete . 
                        3. void join(long millis) // join with time 
                        4. void run() // has a actual functionaliy of a thread . 
                        5. void start() // this method knows how to run a thread has a multithreading mechanism
18. Static methods :-   1. int activeCount() // tells how many threads are active in a group 
                        2. Thread currentThread() // gives a reference of a running thread.
                        3. void yield() //if higher priroty thread takes more cpu time and low priority thread waits longer leading to starvation so high priority thread can 
                                          yield() and allow complete other low prioity thread . 
                        4. void dumpsStack() //stack of an application , we can know the depth of execution stack . 
       
